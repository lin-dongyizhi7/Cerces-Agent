# **Protobuf 3** 定义数据结构 #

### 一、基础拦截配置类 ###

用于定义需要追踪的算子规则，是“追踪开关”的配置载体。

#### 1. InterceptSymbol ####

定义**单个需要拦截/追踪的算子**的属性，比如要追踪哪个函数、算子类型等：

```ProtoBuf
message InterceptSymbol {
  string func_name = 1;    // 要拦截的函数名（如 cublasGemmEx）
  string func_type = 2;    // 函数类型（如 matmul/nccl/memory）
  string operation = 3;    // 具体操作（如 matmul 的正向/反向）
  string algo = 4;         // 算子使用的算法（如 matmul 的算法编号对应的名称）
  string dtype = 5;        // 数据类型（如 float32/float16）
  string coll_type = 6;    // 集合通信类型（仅 NCCL 相关，如 allreduce/allgather）
  bool only_trace = 7;     // 是否仅追踪不干预（true=只记录数据，不修改算子行为）
};
```

#### 2. InterceptSymbolByOffset ####

通过**内存偏移量**映射需要拦截的算子（底层 hook 常用偏移定位函数）：

```ProtoBuf
message InterceptSymbolByOffset {
  map<int64, InterceptSymbol> symbols = 1;  // key=内存偏移量，value=要拦截的算子配置
};
```

### 二、核心调试数据类 ###

针对不同类型的 XPU 操作，定义**结构化的调试/性能数据**（记录算子的输入参数、硬件相关信息）。

#### 1. NcclDebugData ####

记录 **NCCL（GPU 集群通信库）** 集合通信的调试数据：

```ProtoBuf
message NcclDebugData {
  repeated uint32 grids = 1;        // CUDA 核函数的 grid 维度（dim3，如 [x,y,z]）
  repeated uint32 blocks = 2;       // CUDA 核函数的 block 维度（dim3）
  uint64 comm_hash = 3;             // 通信组的哈希值（标识唯一通信组）
  uint64 input_size_in_bytes = 4;   // 输入数据的字节数（不同通信算子含义不同）
  string dtype = 5;                 // 数据类型
  uint32 ranks = 6;                 // 参与通信的 Rank 数量
  uint32 nodes = 7;                 // 参与通信的节点数
  uint64 seq = 8;                   // 通信操作的序列号（按执行顺序递增）
  uint64 problem_size = 9;          // 通信问题规模（如 allreduce 的数据量）
  uint32 send_recv_type = 10;       // 收发类型（如 send/recv/allreduce）
};
```

#### 2. MatmulDebugData ####

记录 **矩阵乘法（Matmul）** 算子的核心参数：

```ProtoBuf
message MatmulDebugData {
  repeated uint32 shapes = 1;       // 矩阵形状 [b, m, n, k]（b=批量，m/n/k=矩阵维度）
  string dtype = 2;                 // 数据类型
  string trans = 3;                 // 转置标识（如 "TN" 表示 A 转置、B 不转置）
  repeated int64 lds = 4;           // 矩阵的领先维度（ldA/ldB/ldC，内存布局相关）
  repeated int64 strides = 5;       // 矩阵的步长（strideA/strideB/strideC）
  int32 algo = 6;                   // 选用的 matmul 算法编号（如 cuBLAS 算法）
  string api = 7;                   // 调用的 API 名称（如 cublasGemmEx/cutlassGemm）
};
```

#### 3. FaDebugData ####

记录 **注意力机制（FA，Flash Attention）** 算子的形状：

```ProtoBuf
message FaDebugData {
  repeated uint32 shapes = 1;  // 形状 [b, s, s, h]（b=批量，s=序列长度，h=头数）
};
```

#### 4. GroupedMatmulDebugData ####

记录 **分组矩阵乘法**（多个 matmul 合并执行）的信息：

```ProtoBuf
message GroupedMatmulDebugData {
  message BMNK {
    repeated uint32 shapes = 1;  // 单个子 matmul 的 [b,m,n,k]
  }
  repeated BMNK bmnks = 1;       // 所有子 matmul 的形状列表
  string dtype = 2;              // 数据类型
  string api = 3;                // 调用的 API 名称
  double tflops = 4;             // 该分组 matmul 的算力（TFLOPS）
};
```

#### 5. MemoryDebugData ####

记录 **内存操作**（申请/释放/拷贝）的调试数据：

```ProtoBuf
message MemoryDebugData {
  uint64 size = 1;          // 内存操作的字节数
  string direction = 2;     // 内存方向（如 H2D=主机到设备，D2H=设备到主机，D2D=设备内）
};
```

#### 6. GcDebugData ####

记录 **垃圾回收（GC）** 的统计数据（主机侧）：

```ProtoBuf
message GcDebugData {
  uint32 collected = 1;        // 成功回收的对象数
  uint32 uncollectable = 2;    // 无法回收的对象数
};
```

### 三、追踪记录类 ###

将“时间信息 + 调试数据”封装，形成完整的**性能追踪记录**。

#### 1. KernelTrace ####

记录 **XPU 核函数（Kernel）** 的单次性能追踪数据（核心结构）：

```ProtoBuf
message KernelTrace {
  uint32 kernel_type = 1;      // 核函数类型（枚举值，如 1=matmul，2=NCCL，3=FA）
  uint32 trace_code = 2;       // 追踪状态码（如 0=成功，1=失败，2=超时）
  uint64 start_us = 3;         // 核函数启动时间（微秒，时间戳）
  uint32 dur_us = 4;           // 核函数执行耗时（微秒）
  uint32 delay_us = 5;         // 核函数等待启动的延迟（微秒）
  uint64 trace_id = 6;         // 唯一追踪 ID（用于关联上下游操作）
  oneof debug_data {           // 变体字段：仅存储一种类型的调试数据（节省空间）
    MatmulDebugData mm_debug = 7;
    FaDebugData fa_debug = 8;
    NcclDebugData nccl_debug = 9;
    MemoryDebugData memory_debug = 10;
    GroupedMatmulDebugData grouped_mm_debug = 12;
  }
  bool is_host = 11;           // 是否是主机侧执行（false=设备侧 Kernel）
};
```

关键：`oneof` 是 Protobuf 的变体类型，保证一个 `KernelTrace` 只存一种算子的调试数据（比如 matmul 就不会同时存 NCCL 数据）。

#### 2. HostTrace ####

记录 **主机侧（CPU）** 操作的追踪数据（非 Kernel 操作）：

```ProtoBuf
message HostTrace {
  uint64 start_us = 1;    // 操作启动时间（微秒）
  uint32 dur_us = 2;      // 操作耗时（微秒）
  string name = 3;        // 操作名称（如 "python_gc"、"data_loader"）
  uint32 count = 4;       // 该操作的执行次数
  oneof debug_data {      // 变体字段：仅存储主机侧特定调试数据
    GcDebugData gc_debug = 5;  // 目前仅支持 GC 调试数据
  }
};
```

### 四、聚合类 ###

将单条追踪记录按维度聚合，方便批量传输/存储。

#### 1. MatmulInfo + MatmulInfos + RankMatmulInfo ####

针对 matmul 算子的**多层聚合**（单条 matmul 信息 → 批量 → 按 Rank 分组）：

```ProtoBuf
message MatmulInfo {
  MatmulDebugData mm_debug = 1;  // matmul 基础参数
  repeated double tflops = 2;    // 该 matmul 的算力列表（多次执行的 TFLOPS）
};

message MatmulInfos {
  repeated MatmulInfo infos = 1;  // 批量 matmul 信息
};

message RankMatmulInfo {
  map<int64, MatmulInfos> mm_infos = 1;  // key=Rank ID，value=该 Rank 的 matmul 列表
};
```

#### 2. KernelTraces ####

最终的**顶层聚合结构**，包含某进程/某 Rank 的所有追踪数据：

```ProtoBuf
message KernelTraces {
  repeated KernelTrace traces = 1;    // 设备侧 Kernel 追踪列表
  repeated HostTrace host_traces = 2; // 主机侧操作追踪列表
  uint32 pid = 3;                     // 进程 ID（标识哪个进程的追踪数据）
  uint32 rank = 4;                    // 分布式训练的 Rank ID（标识哪个节点/卡）
};
```

